<!-- app/static/css/style.css -->
<style>
/* Unkraut-2025 Custom Styles */
:root {
    --primary-green: #28a745;
    --secondary-green: #20c997;
    --dark-green: #155724;
    --light-green: #d4edda;
    --warning-orange: #fd7e14;
    --danger-red: #dc3545;
}

body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    margin-bottom: 60px; /* Space for fixed status bar */
    background-color: #f8f9fa;
}

.navbar-brand {
    font-weight: bold;
    font-size: 1.5rem;
}

.card {
    border: none;
    border-radius: 10px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    transition: transform 0.2s ease-in-out;
}

.card:hover {
    transform: translateY(-2px);
}

.card-header {
    border-radius: 10px 10px 0 0 !important;
    border: none;
    font-weight: 600;
}

.btn {
    border-radius: 8px;
    font-weight: 500;
    transition: all 0.2s ease-in-out;
}

.btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
}

/* Control Panel Styles */
.control-panel {
    background: linear-gradient(135deg, var(--primary-green), var(--secondary-green));
    border-radius: 15px;
    padding: 20px;
    color: white;
}

.direction-pad {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    grid-template-rows: repeat(3, 1fr);
    gap: 10px;
    max-width: 200px;
    margin: 0 auto;
}

.direction-btn {
    width: 60px;
    height: 60px;
    border: none;
    border-radius: 50%;
    background: rgba(255,255,255,0.2);
    color: white;
    font-size: 1.2rem;
    transition: all 0.2s ease;
    backdrop-filter: blur(10px);
}

.direction-btn:hover {
    background: rgba(255,255,255,0.3);
    transform: scale(1.1);
}

.direction-btn:active {
    transform: scale(0.95);
    background: rgba(255,255,255,0.4);
}

.direction-btn.up { grid-column: 2; grid-row: 1; }
.direction-btn.left { grid-column: 1; grid-row: 2; }
.direction-btn.stop { grid-column: 2; grid-row: 2; background: var(--danger-red); }
.direction-btn.right { grid-column: 3; grid-row: 2; }
.direction-btn.down { grid-column: 2; grid-row: 3; }

/* Speed Control */
.speed-control {
    background: rgba(255,255,255,0.1);
    border-radius: 10px;
    padding: 15px;
    backdrop-filter: blur(10px);
}

.speed-slider {
    -webkit-appearance: none;
    appearance: none;
    width: 100%;
    height: 8px;
    border-radius: 5px;
    background: rgba(255,255,255,0.3);
    outline: none;
}

.speed-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: white;
    cursor: pointer;
    box-shadow: 0 2px 6px rgba(0,0,0,0.2);
}

.speed-slider::-moz-range-thumb {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: white;
    cursor: pointer;
    border: none;
    box-shadow: 0 2px 6px rgba(0,0,0,0.2);
}

/* Camera View */
.camera-container {
    position: relative;
    border-radius: 10px;
    overflow: hidden;
    background: #000;
}

.camera-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    pointer-events: none;
    z-index: 10;
}

.detection-box {
    position: absolute;
    border: 2px solid var(--warning-orange);
    background: rgba(253, 126, 20, 0.2);
    border-radius: 4px;
}

.detection-label {
    position: absolute;
    top: -25px;
    left: 0;
    background: var(--warning-orange);
    color: white;
    padding: 2px 6px;
    border-radius: 3px;
    font-size: 0.8rem;
    font-weight: bold;
}

/* Status Indicators */
.status-indicator {
    display: inline-block;
    width: 12px;
    height: 12px;
    border-radius: 50%;
    margin-right: 5px;
    animation: pulse 2s infinite;
}

.status-online {
    background-color: var(--primary-green);
}

.status-offline {
    background-color: var(--danger-red);
}

@keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.5; }
    100% { opacity: 1; }
}

/* Progress Bars */
.progress {
    height: 8px;
    border-radius: 4px;
    background-color: rgba(0,0,0,0.1);
}

.progress-bar {
    border-radius: 4px;
    transition: width 0.6s ease;
}

/* Responsive Design */
@media (max-width: 768px) {
    .container-fluid {
        padding: 10px;
    }
    
    .card {
        margin-bottom: 15px;
    }
    
    .direction-pad {
        max-width: 150px;
    }
    
    .direction-btn {
        width: 45px;
        height: 45px;
        font-size: 1rem;
    }
}

/* Loading Spinner */
.spinner {
    display: inline-block;
    width: 20px;
    height: 20px;
    border: 3px solid rgba(255,255,255,.3);
    border-radius: 50%;
    border-top-color: #fff;
    animation: spin 1s ease-in-out infinite;
}

@keyframes spin {
    to { transform: rotate(360deg); }
}

/* Toast Notifications */
.toast-container {
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 9999;
}

.toast {
    border: none;
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
}
</style>

<!-- app/static/js/app.js -->
<script>
// Unkraut-2025 Main JavaScript
class UnkrautApp {
    constructor() {
        this.socket = null;
        this.isConnected = false;
        this.currentMode = 'manual';
        this.currentSpeed = 50;
        this.init();
    }

    init() {
        this.initSocketIO();
        this.initEventListeners();
        this.startStatusUpdates();
        console.log('Unkraut-2025 App initialized');
    }

    initSocketIO() {
        this.socket = io();
        
        this.socket.on('connect', () => {
            this.isConnected = true;
            this.updateConnectionStatus(true);
            console.log('Connected to server');
        });

        this.socket.on('disconnect', () => {
            this.isConnected = false;
            this.updateConnectionStatus(false);
            console.log('Disconnected from server');
        });

        this.socket.on('sensor_data', (data) => {
            this.updateSensorDisplay(data);
        });

        this.socket.on('motor_status', (data) => {
            this.updateMotorStatus(data);
        });

        this.socket.on('status', (data) => {
            this.showToast(data.msg, 'info');
        });
    }

    initEventListeners() {
        // Keyboard Controls
        document.addEventListener('keydown', (e) => {
            this.handleKeyboard(e);
        });

        document.addEventListener('keyup', (e) => {
            this.handleKeyboardUp(e);
        });

        // Touch Controls for Mobile
        document.addEventListener('touchstart', (e) => {
            e.preventDefault();
        }, { passive: false });
    }

    handleKeyboard(e) {
        if (this.currentMode !== 'manual') return;

        const keyMap = {
            'ArrowUp': 'forward',
            'ArrowDown': 'backward',
            'ArrowLeft': 'left',
            'ArrowRight': 'right',
            'KeyW': 'forward',
            'KeyS': 'backward',
            'KeyA': 'left',
            'KeyD': 'right',
            'Space': 'stop'
        };

        const direction = keyMap[e.code];
        if (direction) {
            e.preventDefault();
            this.moveRobot(direction);
        }
    }

    handleKeyboardUp(e) {
        if (this.currentMode !== 'manual') return;
        
        const stopKeys = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'KeyW', 'KeyS', 'KeyA', 'KeyD'];
        if (stopKeys.includes(e.code)) {
            this.stopRobot();
        }
    }

    moveRobot(direction) {
        const command = {
            direction: direction,
            speed: this.currentSpeed,
            duration: 0.1
        };

        fetch('/api/control/move', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(command)
        })
        .then(response => response.json())
        .then(data => {
            if (data.error) {
                this.showToast(data.error, 'error');
            }
        })
        .catch(error => {
            console.error('Move command failed:', error);
            this.showToast('Bewegungsbefehl fehlgeschlagen', 'error');
        });

        // Socket.IO Alternative
        this.socket.emit('motor_command', command);
    }

    stopRobot() {
        fetch('/api/control/stop', { method: 'POST' })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'stopped') {
                    this.showToast('Roboter gestoppt', 'success');
                }
            })
            .catch(error => {
                console.error('Stop command failed:', error);
            });
    }

    setSpeed(speed) {
        this.currentSpeed = parseInt(speed);
        const speedDisplay = document.getElementById('speed-display');
        if (speedDisplay) {
            speedDisplay.textContent = speed + '%';
        }
    }

    setMode(mode) {
        fetch('/api/control/mode', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ mode: mode })
        })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success') {
                this.currentMode = mode;
                this.updateModeDisplay(mode);
                this.showToast(`Modus geändert zu: ${mode}`, 'success');
            }
        })
        .catch(error => {
            console.error('Mode change failed:', error);
            this.showToast('Modus-Änderung fehlgeschlagen', 'error');
        });
    }

    updateConnectionStatus(connected) {
        const statusElement = document.getElementById('connection-status');
        if (statusElement) {
            if (connected) {
                statusElement.innerHTML = '<i class="fas fa-wifi text-success"></i> Verbunden';
            } else {
                statusElement.innerHTML = '<i class="fas fa-wifi text-danger"></i> Getrennt';
            }
        }
    }

    updateSensorDisplay(data) {
        // Update sensor values in UI
        Object.keys(data).forEach(sensor => {
            const element = document.getElementById(sensor);
            if (element) {
                element.textContent = data[sensor];
            }
        });
    }

    updateMotorStatus(data) {
        const statusElement = document.getElementById('robot-status');
        if (statusElement) {
            statusElement.textContent = data.status;
        }
    }

    updateModeDisplay(mode) {
        const modeElement = document.getElementById('robot-mode');
        if (modeElement) {
            modeElement.textContent = mode.charAt(0).toUpperCase() + mode.slice(1);
        }
    }

    startStatusUpdates() {
        // Update system status every 5 seconds
        setInterval(() => {
            this.updateSystemStatus();
        }, 5000);
    }

    updateSystemStatus() {
        fetch('/api/system/status')
            .then(response => response.json())
            .then(data => {
                // Update status bar
                const cpuTemp = document.getElementById('cpu-temp');
                const memoryUsage = document.getElementById('memory-usage');
                
                if (cpuTemp && data.cpu.temperature) {
                    cpuTemp.textContent = data.cpu.temperature.toFixed(1) + '°C';
                }
                
                if (memoryUsage && data.memory.percent) {
                    memoryUsage.textContent = data.memory.percent.toFixed(1) + '%';
                }
            })
            .catch(error => {
                console.error('Status update failed:', error);
            });
    }

    showToast(message, type = 'info') {
        // Create toast notification
        const toastHtml = `
            <div class="toast" role="alert" aria-live="assertive" aria-atomic="true">
                <div class="toast-header">
                    <i class="fas fa-${this.getToastIcon(type)} text-${this.getToastColor(type)}"></i>
                    <strong class="me-auto ms-1">Unkraut-2025</strong>
                    <small class="text-muted">${new Date().toLocaleTimeString()}</small>
                    <button type="button" class="btn-close" data-bs-dismiss="toast"></button>
                </div>
                <div class="toast-body">
                    ${message}
                </div>
            </div>
        `;

        // Add to toast container
        let container = document.querySelector('.toast-container');
        if (!container) {
            container = document.createElement('div');
            container.className = 'toast-container';
            document.body.appendChild(container);
        }

        container.insertAdjacentHTML('beforeend', toastHtml);
        
        // Initialize and show toast
        const toastElement = container.lastElementChild;
        const toast = new bootstrap.Toast(toastElement, { delay: 3000 });
        toast.show();

        // Remove after hiding
        toastElement.addEventListener('hidden.bs.toast', () => {
            toastElement.remove();
        });
    }

    getToastIcon(type) {
        const icons = {
            'success': 'check-circle',
            'error': 'exclamation-triangle',
            'warning': 'exclamation-triangle',
            'info': 'info-circle'
        };
        return icons[type] || 'info-circle';
    }

    getToastColor(type) {
        const colors = {
            'success': 'success',
            'error': 'danger',
            'warning': 'warning',
            'info': 'info'
        };
        return colors[type] || 'info';
    }

    // AI Detection Methods
    detectWeeds() {
        this.showToast('Starte Unkrauterkennung...', 'info');
        
        fetch('/api/ai/detect', { method: 'POST' })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    this.showToast(
                        `${data.detections.length} Unkraut-Objekte erkannt (${data.confidence.toFixed(1)}% Genauigkeit)`,
                        'success'
                    );
                    this.displayDetections(data.detections);
                } else {
                    this.showToast(data.error, 'error');
                }
            })
            .catch(error => {
                console.error('Weed detection failed:', error);
                this.showToast('Unkrauterkennung fehlgeschlagen', 'error');
            });
    }

    displayDetections(detections) {
        // Display detection boxes on camera stream
        const overlay = document.querySelector('.camera-overlay');
        if (overlay) {
            overlay.innerHTML = ''; // Clear previous detections
            
            detections.forEach((detection, index) => {
                const box = document.createElement('div');
                box.className = 'detection-box';
                box.style.left = detection.x + '%';
                box.style.top = detection.y + '%';
                box.style.width = detection.width + '%';
                box.style.height = detection.height + '%';
                
                const label = document.createElement('div');
                label.className = 'detection-label';
                label.textContent = `${detection.class} (${(detection.confidence * 100).toFixed(1)}%)`;
                
                box.appendChild(label);
                overlay.appendChild(box);
            });
            
            // Auto-clear after 5 seconds
            setTimeout(() => {
                overlay.innerHTML = '';
            }, 5000);
        }
    }
}

// Initialize app when DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
    window.unkrautApp = new UnkrautApp();
});

// Global helper functions
function emergencyStop() {
    window.unkrautApp.stopRobot();
    window.unkrautApp.showToast('NOT-STOPP AKTIVIERT!', 'error');
}

function changeMode(mode) {
    window.unkrautApp.setMode(mode);
}

function changeSpeed(speed) {
    window.unkrautApp.setSpeed(speed);
}

function detectWeeds() {
    window.unkrautApp.detectWeeds();
}
</script>